## 라이프타임

*라이프타임*은 컴파일러(더 정확하게는 *빌려오는 검사기*)가 모든 빌려오는 작업이 유효하도록 보장하기 위해 사용하는 구조입니다. 구체적으로, 변수의 라이프타임은 생성될 때 시작되고 소멸될 때 끝납니다. 라이프타임과 범위는 자주 함께 언급되지만, 동일하지 않습니다.

예를 들어, `&`를 사용하여 변수를 빌려오는 경우, 빌려오는 작업은 선언된 위치에 따라 결정되는 라이프타임을 가지게 됩니다. 결과적으로, 빌려오는 작업은 빌려주는 변수가 소멸되기 전에 끝나야 유효합니다. 그러나 빌려오는 작업의 범위는 참조가 사용되는 위치에 따라 결정됩니다.

다음 예제와 이 섹션의 나머지 부분에서는 라이프타임이 범위와 관련되는 방식, 그리고 두 가지가 어떻게 다르게 작동하는지 살펴보겠습니다.

```rust,editable
// 라이프타임은 아래 줄에 표시되어 있으며, 각 변수의 생성 및 소멸을 나타냅니다.
// `i`는 범위가 `borrow1`과 `borrow2`를 모두 포함하기 때문에 가장 긴 라이프타임을 가지고 있습니다. `borrow1`과 `borrow2`의 지속 시간은 서로 독립적이기 때문에 중요하지 않습니다.
fn main() {
    let i = 3; // `i`의 라이프타임 시작. ────────────────┐
    //                                                     │
    { //                                                   │
        let borrow1 = &i; // `borrow1` 라이프타임 시작. ──┐│
        //                                                ││
        println!("borrow1: {}", borrow1); //              ││
    } // `borrow1` 종료. ─────────────────────────────────┘│
    //                                                     │
    //                                                     │
    { //                                                   │
        let borrow2 = &i; // `borrow2` 라이프타임 시작. ──┐│
        //                                                ││
        println!("borrow2: {}", borrow2); //              ││
    } // `borrow2` 종료. ─────────────────────────────────┘│
    //                                                     │
}   // 라이프타임 종료. ─────────────────────────────────────┘
```

참고로, 라이프타임에 이름이나 유형이 할당되지 않습니다. 이는 라이프타임이 사용될 수 있는 방식을 제한합니다. 이후에 살펴보겠습니다.
