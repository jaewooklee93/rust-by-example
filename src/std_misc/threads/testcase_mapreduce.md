## 테스트 케이스: 맵-리듀스

Rust는 데이터 처리를 병렬화하는 데 매우 쉽습니다. 전통적으로 이러한 시도와 관련된 많은 어려움을 피할 수 있습니다.

표준 라이브러리는 훌륭한 스레드 프레임워크를 제공합니다.
이러한 프레임워크는 Rust의 소유권 및 별칭 규칙 개념과 결합되어 데이터 레이스를 자동으로 방지합니다.

별칭 규칙(쓰기 가능한 참조 하나 XOR 읽기 가능한 참조 여러 개)은 다른 스레드에 의해 표시되는 상태를 조작하는 것을 자동으로 방지합니다. (동기화가 필요한 경우 `Mutex` 또는 `Channel`과 같은 동기화 프레임워크가 있습니다.)

이 예제에서는 숫자 블록의 모든 숫자의 합을 계산합니다. 이를 위해 블록의 조각을 다른 스레드로 나눕니다. 각 스레드는 작은 숫자 블록의 합을 계산하고, 이후 각 스레드에서 생성된 중간 합을 합산합니다.

참고로 스레드 경계를 넘어 참조를 전달하고 있지만, Rust는 우리가 읽기 전용 참조만 전달하고 있음을 이해하며, 따라서 안전하지 않거나 데이터 레이스가 발생할 수 없습니다. 또한 전달하는 참조가 `'static` 라이프타임을 가지고 있기 때문에 Rust는 우리의 데이터가 이 스레드가 실행 중인 동안 파괴되지 않음을 이해합니다. (스레드 간에 비 `'static` 데이터를 공유해야 하는 경우 `Arc`와 같은 스마트 포인터를 사용하여 데이터를 유지하고 비 `'static` 라이프타임을 피할 수 있습니다.)

```rust,editable
use std::thread;

// 이것은 `main` 스레드입니다
fn main() {

    // 이것은 처리할 데이터입니다.
    // 우리는 스레드 기반 맵-리듀스 알고리즘을 사용하여 모든 숫자의 합을 계산합니다.
    // 각 빈칸으로 구분된 블록이 다른 스레드에서 처리됩니다.
    //
    // TODO: 빈칸을 삽입하면 출력이 어떻게 변하는지 확인하세요!
    let data = "86967897737416471853297327050364959
11861322575564723963297542624962850
70856234701860851907960690014725639
38397966707106094172783238747669219
52380795257888236525459303330302837
58495327135744041048897885734297812
69920216438980873548808413720956532
16278424637452589860345374828574668";

    // 자식 스레드를 저장할 벡터를 만듭니다.
    let mut children = vec![];

    /*************************************************************************
     * "맵" 단계
     *
     * 데이터를 세그먼트로 나누고 초기 처리를 적용합니다
     ************************************************************************/

    // 데이터를 세그먼트로 나누고 개별 계산을 위한 참조를 만듭니다.
    // 각 덩어리는 실제 데이터에 대한 참조(&str)입니다.
    let chunked_data = data.split_whitespace();

    // 데이터 세그먼트를 반복합니다.
    // .enumerate()는 현재 루프 인덱스를 반복되는 항목에 추가합니다.
    // 결과 튜플 "(index, element)"는 즉시 "destructuring assignment"으로 두 변수 "i"와 "data_segment"로 분해됩니다.
    for (i, data_segment) in chunked_data.enumerate() {
        println!("데이터 세그먼트 {}는 \"{}\"" , i, data_segment);

        // 각 데이터 세그먼트를 별도의 스레드에서 처리합니다.
        //
        // spawn()는 새 스레드에 대한 핸들을 반환합니다.
        // 이 핸들은 새 스레드의 결과를 가져오기 위해 반드시 유지해야 합니다.
        //
        // 'move || -> u32'는 폐쇄 문법입니다.
        // * 인수를 취하지 않습니다 ('||')
        // * 캡처된 변수의 소유권을 가져옵니다 ('move')
        // * 32비트 무符号 정수 ('-> u32')를 반환합니다.
        //
        // Rust는 '-> u32'를 폐쇄에서 반환하는 값으로부터 추론할 수 있습니다.
        // 즉시 실행되는 함수를 닫기 때문에, 이 부분을 생략해도 괜찮습니다.
        //
        // TODO: 'move'를 제거하고 실행 결과를 확인해보세요
        children.push(thread::spawn(move || -> u32 {
            // 해당 구간의 중간 합을 계산합니다:
            let result = data_segment
                        // 문자열 구간의 각 문자를 반복합니다..
                        .chars()
                        // .. 문자를 숫자 값으로 변환합니다..
                        .map(|c| c.to_digit(10).expect("숫자여야 합니다"))
                        // .. 숫자로 변환된 이터레이터의 합을 계산합니다
                        .sum();

            // println!은 stdout을 잠그므로, 텍스트가 섞이지 않습니다.
            println!("처리된 구간 {}, 결과={}", i, result);

            // "return"이 필요하지 않습니다. Rust는 "표현식 언어"이기 때문에, 각 블록의 마지막 평가된 표현식이 자동으로 그 값이 됩니다.
            result

        }));
    }


    /*************************************************************************
     * "Reduce" 단계
     *
     * 중간 결과를 수집하고, 최종 결과로 결합합니다
     ************************************************************************/

    // 각 스레드의 중간 결과를 하나의 최종 합으로 결합합니다.
    //
    // "turbofish" ::<>를 사용하여 sum()에 유형 힌트를 제공합니다.
    //
    // TODO: turbofish 없이, final_result의 유형을 명시적으로 지정하여 시도해보세요
    let final_result = children.into_iter().map(|c| c.join().unwrap()).sum::<u32>();

    println!("최종 합 결과: {}", final_result);
}


```

### 과제
사용자 입력 데이터에 따라 스레드 수를 결정하는 것은 현명하지 않습니다.
사용자가 많은 공백을 입력하도록 하면, 2,000개의 스레드를 생성하고 싶을까요?
프로그램을 수정하여 데이터가 항상 프로그램의 시작 부분에 정의된 제한된 개수의 덩어리로 나뉘도록 합니다.

### 참조
* [스레드][thread]
* [벡터][vectors] 및 [이터레이터][iterators]
* [클로저][closures], [move][move] 세mantics 및 [`move` 클로저][move_closure]
* [구조 분해][destructuring] 할당
* [turbofish 표기법][turbofish]을 사용하여 유형 추론을 돕습니다.
* [unwrap vs. expect][unwrap]
* [enumerate][enumerate]

[thread]: ../threads.md
[vectors]: ../../std/vec.md
[iterators]: ../../trait/iter.md
[destructuring]: https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html?highlight=destructuring
[closures]: ../../fn/closures.md
[move]: ../../scope/move.md
[move_closure]: https://doc.rust-lang.org/book/ch13-01-closures.html#closures-can-capture-their-environment
[turbofish]: https://doc.rust-lang.org/book/appendix-02-operators.html?highlight=turbofish
[unwrap]: ../../error/option_unwrap.md
[enumerate]: https://doc.rust-lang.org/book/loops.html#enumerate
